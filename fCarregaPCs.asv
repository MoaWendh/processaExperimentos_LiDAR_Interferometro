%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Moacir Wendhausen
% 26/11/2022
% Função que carrega as nuvens de pontos que foram convertidas a partir dos 
% arquivos "xls" gerados no experiento com o laser interferométrico
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

function fCarregaPCs(path, name, param)
clc;
close all

% Faz a leitura de todas as nuvens de pontos no formato '.pcd'.
ctPos= 0;
for (ctFolder=1:param.numFolders) 
    pathFolder= sprintf('%s%s%0.4d\\', path.Base, name.FolderBase, ctFolder*200);
    % Verifica os folders
    infoFolder= dir(fullfile(pathFolder, '*.pcd'));
    %¨numFiles= length(infoFolder(not([infoFolder.isdir])));
    for (ctFile= param.fileIni:param.fileEnd)
        ctPos= ctPos+1;
        nameFile= sprintf('%s%d_%0.4d.%s', name.FileBase, ctFolder*200, ctFile, name.extPC);
        fullPathFile = fullfile(path.Folder, nameFile);
        pc{ctFolder,ctFile - param.fileIni+1}= pcread(fullPathFile);  
        % Filtra o ruído da nuvem de pontos a ser registrada.
        pcDenoised{ctFolder,ctFile - param.fileIni+1} = pcdenoise(pc{ctFolder,ctFile - param.fileIni+1});
    end
    if (param.showPC)
        close all;
        handle= figure;
        subplot(1,2,1);
        pcshow(pc{ctFolder,ctFile});
        subplot(1,2,2);
        pcshow(pcDenoised{ctFolder,ctFile});
        handle.WindowState='maximized';
    end
end

% Toma a primeira PC como referência.
pcFull= pcDenoised{1,1};

% Faz uma subamostragem.
% pcDownSampleRef= pcdownsample(pcFull, 'gridAverage', gridSize); 
pcDownSampleRef= pcdownsample(pcFull, 'nonuniformGridSample', maxNumPoints);

% Cria uma tranformação neutra
tformAccum= affine3d;

for (ctPC=2:numFolders)
   pcAux= pc{ctPC,1};
   
   % Faz uma sub-amostragem no PC, este procedimento melhora o desempenho
   % da função pcregistericp(). Usando o 'gridAverage' com oparâmetro 
   % 'gridSize' define a aresta de um cubo 3D, em metros. O 'gridAverage' 
   % pode ser adotado em métricas para registro tanto 'pointToPlane' quanto
   % 'planeToPlane'. 
   pcDownSample= pcdownsample(pcAux, 'gridAverage', gridSize);
   
   % O parâmetro 'nonuniformGridSample' tem melhor desempenho quando a
   % métrica usada no registro das PC é 'pointToPlane'.
   % pcDownSample= pcdownsample(pcAux, 'nonuniformGridSample', maxNumPoints);
   
   % Calcula a tranformação de corpo rígido, podem ser usados 3 tipos de
   % algoritmos, ICP, CPD e NDT
   if (useICP)
        tformAux = pcregistericp(pcDownSample, pcDownSampleRef, 'Metric','pointToPlane','Extrapolate', true);
   elseif (useCPD)
        tformAux = pcregistericp(pcDownSample, pcDownSampleRef, 'Metric','pointToPlane','Extrapolate', true);   
   elseif (useNDT)
        tformAux = pcregistericp(pcDownSample, pcDownSampleRef, 'Metric','pointToPlane','Extrapolate', true);
   end
   
   % Acumula a transformação a cada iteração. 
   tformAccum = affine3d(tformAux.T * tformAccum.T);
   
   % Executa o registro, alinhamento das PCs.
   pcAligned = pctransform(pcAux, tformAccum);
   
   % Faz a fusão das PC a cada iteração.
   pcFull = pcmerge(pcFull, pcAligned, mergeSize);
   
   % Armazena o PC atual na variável "pcDownSampleRef" para a próxima
   % iteração.
   pcDownSampleRef= pcDownSample;
   
   % Guarda algumas variáveis para análise posterior:
   tform{ctPC-1}= tformAux; 
   translation(ctPC-1,:)= tformAux.Translation(1,:);
   
   % Exibe o resultado do registro das PCs a cada iteração
   if (showPCReg)
       if (ctPC==2)
           handle= figure;
       end
       pcshow(pcFull);

       title('PCs concatenadas');
       xlabel('X (m)');
       ylabel('Y (m)');
       zlabel('Z (m)');
       handle.WindowState='maximized';
   end  
end

% Análise do registro das PCs:
vetorTranslRef= [0 0 0];

posLiDAR_EixoX= 0;

for (ct=1:(numFolders-1))
    % Converte os valores em mm:
    vetorTransl(ct,:)= translation(ct,:)*1000;
    
    % Calcula o módulo do vetor diferença das translações. Se for zero
    % a translação da transformação de corpo rigido foi ideal:
    normDiffVetorTransl(ct)= (norm(vetorTransl(ct,:)));
    
    % Determina o deslocamento medido pelo interferômetro para cada
    % posição:
    posInterferometro(ct)= medicoesInterferometro_exp_01(ct+1) - medicoesInterferometro_exp_01(ct); 
    
    % Calcula o deslocamento integral do LiDAR ao longo do eixo X:
    if (ct==1)
        integraPosLiDAR_EixoX(ct)= vetorTransl(1);
    else
        integraPosLiDAR_EixoX(ct)= integraPosLiDAR_EixoX(ct-1) + vetorTransl(ct,1);
    end
end

dataA= normDiffVetorTransl(1,:); 
dataB= posInterferometro;
erroX= (posInterferometro - normDiffVetorTransl(1,:))

figure;
% Top bar graph
ax1 = nexttile;
bar(ax1,dataA,'g');
ax1.XLabel.String='Passo LiDAR';
ax1.YLabel.String='Valor passo (mm)';

% Bottom bar graph
ax2 = nexttile;
bar(ax2,dataB,'b')
ax2.XLabel.String='Passo Interferômetro';
ax2.YLabel.String='Valor passo (mm)';

% Bottom bar graph
ax3 = nexttile;
bar(ax3,erroX,'r')
ax3.XLabel.String='Erro: LiDAR X interferômetro';
ax3.YLabel.String='Erro passo (mm)';

% Bottom bar graph
ax4 = nexttile;
bar(ax4,vetorTransl)
ax4.XLabel.String='Passos do LiDAR nos eixos X, Y e Z';
ax4.YLabel.String='Valor passo (mm)';

% Analisa desempenho do LiDAR com relação ao eixo "X"
figure;
subplot(2,2,1);
a=bar(vetorTransl);
xlabel('num PC');
ylabel('mm');
title('Deslocamento do LiDAR: Eixos X, Y e Z pelo Algoritmo Matlab');

subplot(2,2,2);
dataX= [normDiffVetorTransl(1,:); posInterferometro];
b=bar(dataX);
xlabel('num PC');
ylabel('mm');
title('Deslocamento: Registro PC x Interferêmetro');

subplot(2,2,3);
erroX= (posInterferometro - normDiffVetorTransl(1,:));
c=bar(erroX);
xlabel('num PC');
ylabel('mm');
title('Erro do deslocamento do LiDAR com relação ao Interferômetro - eixo X ');

subplot(2,2,4);
plot(medicoesInterferometro_exp_01(1:14), integraPosLiDAR_EixoX,'-b');



% Analisa desempenho do LiDAR com relação ao eixo "Y"
maxVal=-999;
minVal= 999;
zeroXYZ= [0 0 0];
figure;
for (ct=1:length(diffVetorTransl))  
    if (max(diffVetorTransl(ct,:)) > maxVal)
        maxVal= max(diffVetorTransl(ct,:));
    end
    if (min(diffVetorTransl(ct,:)) < minVal)
        minVal= min(diffVetorTransl(ct,:));
    end
    
    quiver3(zeroXYZ(1),zeroXYZ(2),zeroXYZ(3),diffVetorTransl(ct,1),diffVetorTransl(ct,2),diffVetorTransl(ct,3));
    hold on;
end

xlim([minVal maxVal]);
ylim([minVal maxVal]);
zlim([minVal maxVal]);

xlim([-maxVal maxVal]);
ylim([-maxVal maxVal]);
zlim([-maxVal maxVal]);

